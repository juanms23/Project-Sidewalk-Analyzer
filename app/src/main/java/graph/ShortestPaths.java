package graph;

import heap.Heap;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Stack;
import java.util.HashMap;
import java.util.LinkedList;
import java.io.File;
import java.io.FileNotFoundException;

/*Authors: Danann Gallagher, Juan Carlos Muratalla-Sanchez 
 * Date: 12/2/22
 * Class: CSCI 241
 * Purpose: Provides an implementation of Dijkstra's single-source shortest paths
 * algorithm, for the fourth programming project of the class
 */

/** Provides an implementation of Dijkstra's single-source shortest paths
 * algorithm.
 * Sample usage:
 *   Graph g = // create your graph
 *   ShortestPaths sp = new ShortestPaths();
 *   Node a = g.getNode("A");
 *   sp.compute(a);
 *   Node b = g.getNode("B");
 *   LinkedList<Node> abPath = sp.getShortestPath(b);
 *   double abPathLength = sp.getShortestPathLength(b);
 *   */
public class ShortestPaths {
    // stores auxiliary data associated with each node for the shortest
    // paths computation:
    private HashMap<Node,PathData> paths;

    /** Compute the shortest path to all nodes from origin using Dijkstra's
     * algorithm. Fill in the paths field, which associates each Node with its
     * PathData record, storing total distance from the source, and the
     * backpointer to the previous node on the shortest path.
     * Precondition: origin is a node in the Graph.*/
    public void compute(Node origin) {
        paths = new HashMap<Node,PathData>();                              //Set paths equal to a new Hashmap
        PathData originPathData = new PathData(0.0, null);
        paths.put(origin, originPathData);                                //Added that origin ino the paths hashmap
        Heap<Node, Double> F = new Heap<>();                              //Initialized the min heap that will keep track of the Frontier
        F.add(origin, 0.0);                                               //Adding the origin with a distanc eto itself of 0

        while(F.size() != 0){                                             //Loops through the Frontier until there are no more values
            Node f = F.poll();                                            //sets f as the value in the frontier with the lowest distance
            f.getNeighbors().forEach((wNode, weight) -> {                 //loops through all neighbors of f
                if(paths.containsKey(wNode) == false){
                    double wd =  paths.get(f).distance + weight;
                    Node wbp = f;
                    PathData fData = new PathData(wd, wbp);
                    paths.put(wNode,fData);
                    F.add(wNode,fData.distance);
                }else if((paths.get(f).distance + weight) < paths.get(wNode).distance){
                    double wNodeDist= (paths.get(f).distance + weight);
                    Node wNodePrev = f;
                    paths.put(wNode, new PathData(wNodeDist,wNodePrev));
                    F.changePriority(wNode, wNodeDist);
                }

            });

        }
    }

    /** Returns the length of the shortest path from the origin to destination.
     * If no path exists, return Double.POSITIVE_INFINITY.
     * Precondition: destination is a node in the graph, and compute(origin)
     * has been called. */
    public double shortestPathLength(Node destination) {
        if(paths.containsKey(destination) == false){   //case where there is no path to the value
            return Double.POSITIVE_INFINITY;
        }
        return paths.get(destination).distance;       //looks up distance value from the paths hashmap
    }

    /** Returns a LinkedList of the nodes along the shortest path from origin
     * to destination. This path includes the origin and destination. If origin
     * and destination are the same node, it is included only once.
     * If no path to it exists, return null.
     * Precondition: destination is a node in the graph, and compute(origin)
     * has been called. */
    public LinkedList<Node> shortestPath(Node destination) {
        if(paths.containsKey(destination) == false){
            return null;
        }
        Stack<Node> stack = new Stack<Node>(); //Initalizes a tack in order to reverse the decending order of the path
        Node Holder = destination;
        while(Holder != null){
            stack.push(Holder);
            Holder = paths.get(Holder).previous;
        }
        LinkedList<Node> order = new LinkedList<Node>();
        while(!stack.isEmpty()){
            order.add(stack.pop());  //Pops the stack of the decending path onto a linked list representing the path
        }return order;              //returns the linked list generated by the path from the origin to a destination
    }


    /** Inner class representing data used by Dijkstra's algorithm in the
     * process of computing shortest paths from a given source node. */
    class PathData {
        double distance; // distance of the shortest path from source
        Node previous; // previous node in the path from the source

        /** constructor: initialize distance and previous node */
        public PathData(double dist, Node prev) {
            distance = dist;
            previous = prev;
        }
    }


    /** Static helper method to open and parse a file containing graph
     * information. Can parse either a basic file or a CSV file with
     * sidewalk data. See GraphParser, BasicParser, and DBParser for more.*/
    protected static Graph parseGraph(String fileType, String fileName) throws
        FileNotFoundException {
        // create an appropriate parser for the given file type
        GraphParser parser;
        if (fileType.equals("basic")) {
            parser = new BasicParser();
        } else if (fileType.equals("db")) {
            parser = new DBParser();
        } else {
            throw new IllegalArgumentException(
                    "Unsupported file type: " + fileType);
        }

        // open the given file
        parser.open(new File(fileName));

        // parse the file and return the graph
        return parser.parse();
    }

    public static void main(String[] args) {
      // read command line args
      String fileType = args[0];
      String fileName = args[1];
      String origCode = args[2];

      String destCode = null;
      if (args.length == 4) {
          destCode = args[3];
      }

      // parse a graph with the given type and filename
      Graph graph;
      try {
          graph = parseGraph(fileType, fileName);
      } catch (FileNotFoundException e) {
          System.out.println("Could not open file " + fileName);
          return;
      }
      graph.report();
      
      ShortestPaths sp = new ShortestPaths();
      Node origin = graph.getNode(origCode);
      sp.compute(origin);
      if (args.length != 4){
        for (Node key : sp.paths.keySet()){
            System.out.println(key.getId() + "=" + sp.paths.get(key).distance);
        }
      }
      if (args.length == 4){
        Node dest = graph.getNode(destCode);
        System.out.println("Path length: " + args[2] + " " + args [3] + " " + sp.shortestPathLength(dest));
        LinkedList<Node> order = sp.shortestPath(dest);
        if (order == null){
            System.out.println("Error: no paths exists!");
        } else{
            System.out.print("Path: " );
            for (int i = 0; i < order.size(); i++){
                System.out.print(order.get(i) + " ");
            }
        }
        System.out.println();
      }
    }
}
